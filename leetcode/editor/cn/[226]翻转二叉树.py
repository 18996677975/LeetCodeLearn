"""
# ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œç¿»è½¬è¿™æ£µäºŒå‰æ ‘ï¼Œå¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚ 
# 
#  
# 
#  ç¤ºä¾‹ 1ï¼š 
# 
#  
# 
#  
# è¾“å…¥ï¼šroot = [4,2,7,1,3,6,9]
# è¾“å‡ºï¼š[4,7,2,9,6,3,1]
#  
# 
#  ç¤ºä¾‹ 2ï¼š 
# 
#  
# 
#  
# è¾“å…¥ï¼šroot = [2,1,3]
# è¾“å‡ºï¼š[2,3,1]
#  
# 
#  ç¤ºä¾‹ 3ï¼š 
# 
#  
# è¾“å…¥ï¼šroot = []
# è¾“å‡ºï¼š[]
#  
# 
#  
# 
#  æç¤ºï¼š 
# 
#  
#  æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®èŒƒå›´åœ¨ [0, 100] å†… 
#  -100 <= Node.val <= 100 
#  
# 
#  Related Topicsæ ‘ | æ·±åº¦ä¼˜å…ˆæœç´¢ | å¹¿åº¦ä¼˜å…ˆæœç´¢ | äºŒå‰æ ‘ 
# 
#  ğŸ‘ 1818, ğŸ‘ 0bug åé¦ˆ | ä½¿ç”¨æŒ‡å— | æ›´å¤šé…å¥—æ’ä»¶ 
# 
# 
# 
# 

"""

from typing import *

# leetcode submit region begin(Prohibit modification and deletion)
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

"""
éå†çš„æ–¹å¼
"""
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        self.traverse(root)
        return root

    def traverse(self, root):
        if not root:
            return

        leftNode, rightNode = root.left, root.right
        root.left = rightNode
        root.right = leftNode

        self.traverse(root.left)
        self.traverse(root.right)

"""
åˆ†è§£é—®é¢˜çš„æ–¹å¼
"""
class Solution:
    # å®šä¹‰ï¼šå°†ä»¥ root ä¸ºæ ¹çš„è¿™æ£µäºŒå‰æ ‘ç¿»è½¬ï¼Œè¿”å›ç¿»è½¬åçš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None

        leftTree = self.invertTree(root.left)
        rightTree = self.invertTree(root.right)

        root.left = rightTree
        root.right = leftTree

        return root
# leetcode submit region end(Prohibit modification and deletion)
